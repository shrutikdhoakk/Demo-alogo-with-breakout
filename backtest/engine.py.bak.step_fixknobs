"""Simple backtest engine for the Breakout Momentum strategy."""

from __future__ import annotations

import argparse
from typing import Dict, Any, List, Optional
from datetime import datetime

import numpy as np
import pandas as pd
import yaml

from src.strategy.breakout_momentum_v3 import StrategyConfig, BreakoutMomentumV3
from src.data.ingest import load_csv
from .metrics import cagr, max_drawdown


def _parse_date(s: Optional[str]) -> Optional[pd.Timestamp]:
    if not s:
        return None
    return pd.Timestamp(datetime.strptime(s, "%Y-%m-%d")).normalize()


def _read_universe_csv(path: str) -> List[str]:
    df = pd.read_csv(path)
    cols = [c.lower() for c in df.columns]
    if len(df.columns) == 1:
        return df.iloc[:, 0].astype(str).dropna().tolist()
    if "symbol" in cols:
        return df[df.columns[cols.index("symbol")]].astype(str).dropna().tolist()
    if "symbols" in cols:
        return df[df.columns[cols.index("symbols")]].astype(str).dropna().tolist()
    return df.iloc[:, 0].astype(str).dropna().tolist()


def _normalize_index(df: pd.DataFrame) -> pd.DataFrame:
    """Ensure DatetimeIndex (tz-naive), sorted, unique â€” without using tz_* APIs."""
    parsed = pd.to_datetime(df.index, errors="coerce")  # tz-naive
    mask = ~pd.isna(parsed)
    df = df.loc[mask].copy()
    df.index = pd.DatetimeIndex(parsed[mask])  # DatetimeIndex, tz-naive
    df.sort_index(inplace=True)
    df = df[~df.index.duplicated(keep="last")]
    return df


def _pos_at(df: pd.DataFrame, date: pd.Timestamp) -> Optional[int]:
    """Return integer position of 'date' in df.index, or None if missing."""
    idx = int(df.index.get_indexer([date])[0])
    return None if idx == -1 else idx


class BacktestEngine:
    """Driver class to perform a backtest over a universe of symbols."""

    def __init__(
        self,
        config_path: str = "backtest/config.yaml",
        start_date: Optional[pd.Timestamp] = None,
        end_date: Optional[pd.Timestamp] = None,
        universe_csv: Optional[str] = None,
        max_positions_override: Optional[int] = None,
    ):
        # Read configuration
        with open(config_path, "r", encoding="utf-8") as f:
            self.cfg: Dict[str, Any] = yaml.safe_load(f) or {}

            # DEBUG: log which parameters were loaded from YAML (engine)
            try:
                import json, hashlib
                _hash = hashlib.sha1(
                    json.dumps(self.cfg, sort_keys=True, default=str).encode()
                ).hexdigest()[:8]
            except Exception:
                _hash = "nohash"
            print(
                "USING_PARAMS",
                "scope=engine",
                f"hash={_hash}",
                f"breakout_atr_buf={self.cfg.get('breakout_atr_buf')}",
                f"trail_atr_mult={self.cfg.get('trail_atr_mult')}",
                f"atr_pct_max={self.cfg.get('atr_pct_max')}",
                sep=" | ",
            )

        # Risk parameters
        self.total_capital: float = float(self.cfg.get("TOTAL_CAPITAL", 10000.0))
        self.max_invested: float = float(self.cfg.get("MAX_INVESTED", 5000.0))
        self.per_trade_risk: float = float(self.cfg.get("PER_TRADE_RISK", 1000.0))
        self.slippage: float = float(self.cfg.get("SLIPPAGE", 0.001))
        self.fee: float = float(self.cfg.get("FEE", 0.0003))

        # Positions limit
        default_max_pos = int(self.cfg.get("MAX_POSITIONS", 5))
        self.max_positions: int = int(max_positions_override or default_max_pos)

        # Universe
        if universe_csv:
            self.symbols: List[str] = _read_universe_csv(universe_csv)
        else:
            self.symbols = list(self.cfg.get("SYMBOLS", []))

        # Strategy
        # Build StrategyConfig from YAML keys that the strategy actually supports
        sc = StrategyConfig()
        for k, v in self.cfg.items():
            if hasattr(sc, k):
                try:
                    sc.__setattr__(k, float(v))
                except Exception:
                    sc.__setattr__(k, v)
        self.strategy = BreakoutMomentumV3(sc)
        # Load, clamp, features, normalize
        self.data: Dict[str, pd.DataFrame] = {}
        for sym in self.symbols:
            df = load_csv(sym)
            if start_date is not None:
                df = df[df.index >= start_date]
            if end_date is not None:
                df = df[df.index <= end_date]
            if df.empty:
                continue
            df = self.strategy.compute_features(df)
            df = _normalize_index(df)  # <- critical
            self.data[sym] = df

        # Build union of dates
        all_dates = set()
        for df in self.data.values():
            all_dates.update(df.index)
        dates_sorted = sorted(all_dates)

        # Clamp at engine level too
        if start_date is not None:
            dates_sorted = [d for d in dates_sorted if d >= start_date]
        if end_date is not None:
            dates_sorted = [d for d in dates_sorted if d <= end_date]
        self.dates = dates_sorted

        # State
        self.capital: float = self.total_capital
        self.portfolio: Dict[str, Dict[str, Any]] = {}
        self.trades: List[Dict[str, Any]] = []
        self.equity_curve: List[Dict[str, Any]] = []
        # debug counters
        self._cand_total = 0
        self._cand_dates = 0
        self._orders_attempted = 0
        self._orders_filled = 0

    def run(self) -> None:
        """Execute the backtest over the prepared date range."""
        for date in self.dates:
            # -------- exits --------
            for sym in list(self.portfolio.keys()):
                pos = self.portfolio[sym]
                df_sym = self.data.get(sym)
                if df_sym is None:
                    continue
                i = _pos_at(df_sym, date)
                if i is None:
                    continue
                row = df_sym.iloc[i]
                price = float(row["Close"])

                exit_reason = None
                exit_price: Optional[float] = None

                # trail update/activation
                if pos.get("trail_active", False):
                    trail_stop = price - pos["atr"] * self.strategy.cfg.chandelier_mult
                    if trail_stop > pos["trail_stop"]:
                        pos["trail_stop"] = trail_stop
                else:
                    if (price - pos["entry"]) >= self.strategy.cfg.trail_trigger_atr * pos["atr"]:
                        pos["trail_active"] = True
                        pos["trail_stop"] = price - pos["atr"] * self.strategy.cfg.chandelier_mult

                # stops/targets
                if price <= pos["stop"]:
                    exit_price = price * (1 - self.slippage)
                    exit_reason = "stop"
                elif price >= pos["target"]:
                    exit_price = price * (1 - self.slippage)
                    exit_reason = "target"
                elif pos.get("trail_active", False) and price <= pos["trail_stop"]:
                    exit_price = price * (1 - self.slippage)
                    exit_reason = "trail"
                # early exit
                elif self.strategy.should_early_exit(df_sym, i):
                    exit_price = price * (1 - self.slippage)
                    exit_reason = "early"

                if exit_price is not None:
                    shares = pos["shares"]
                    proceeds = exit_price * shares
                    entry_cost = pos["entry"] * shares
                    self.capital += proceeds - self.fee * proceeds - self.fee * entry_cost
                    self.trades.append(
                        {
                            "symbol": sym,
                            "entry_date": pos["entry_date"],
                            "entry_price": pos["entry"],
                            "exit_date": date,
                            "exit_price": exit_price,
                            "shares": shares,
                            "reason": exit_reason,
                        }
                    )
                    del self.portfolio[sym]

            # -------- mark to market --------
            invested_value = 0.0
            for sym, pos in self.portfolio.items():
                df_sym = self.data.get(sym)
                if df_sym is None:
                    continue
                j = _pos_at(df_sym, date)
                if j is None:
                    continue
                invested_value += float(df_sym.iloc[j]["Close"]) * pos["shares"]
            total_value = float(self.capital + invested_value)
            self.equity_curve.append({"date": date, "value": total_value})

            # -------- entries --------
            candidates: List[tuple[float, str, pd.Series]] = []
            for sym, df_sym in self.data.items():
                if sym in self.portfolio:
                    continue
                k = _pos_at(df_sym, date)
                if k is None:
                    continue
                row = df_sym.iloc[k]
                # warm-up / first row skip
                if k == 0 or bool(row.get("_WARMUP", False)):
                    continue
                prev = df_sym.iloc[k - 1]
                if self.strategy.is_entry(row, prev):
                    candidates.append((self.strategy.score(row), sym, row))

            # debug: count daily candidates
            self._cand_total += len(candidates)
            if candidates:
                self._cand_dates += 1
            candidates.sort(reverse=True, key=lambda x: x[0])
            for score, sym, row in candidates:
                self._orders_attempted += 1
                if len(self.portfolio) >= self.max_positions:
                    break

                atr_val = float(row["ATR14"])
                if pd.isna(atr_val) or atr_val <= 0:
                    continue

                close_px = float(row["Close"])
                stop = close_px - self.strategy.cfg.atr_stop_mult * atr_val
                target = close_px + self.strategy.cfg.atr_target_mult * atr_val
                risk_per_share = close_px - stop
                if risk_per_share <= 0:
                    continue

                shares = int(self.per_trade_risk / risk_per_share)
                if shares <= 0:
                    continue

                cost = shares * close_px

                # current invested today
                current_invested = 0.0
                for sym2, pos2 in self.portfolio.items():
                    df2 = self.data.get(sym2)
                    if df2 is None:
                        continue
                    p2 = _pos_at(df2, date)
                    if p2 is None:
                        continue
                    current_invested += float(df2.iloc[p2]["Close"]) * pos2["shares"]
                # Cap shares by available cash and MAX_INVESTED
                cap_by_cash = int(self.capital // close_px)
                cap_by_invested = int(max(0.0, self.max_invested - current_invested) // close_px)
                shares = max(0, min(shares, cap_by_cash, cap_by_invested))
                cost = shares * close_px
                if shares < 1:
                    continue

                if cost > self.capital:
                    continue
                if current_invested + cost > self.max_invested:
                    continue

                entry_price = close_px * (1 + self.slippage)
                self.capital -= cost + self.fee * cost
                self.portfolio[sym] = {
                    "entry_date": date,
                    "entry": entry_price,
                    "shares": shares,
                    "stop": stop,
                    "target": target,
                    "atr": atr_val,
                    "trail_active": False,
                    "trail_stop": stop,
                }
                self._orders_filled += 1

        # -------- force exit remaining --------
        if self.dates:
            last_date = self.dates[-1]
            for sym, pos in list(self.portfolio.items()):
                df_sym = self.data.get(sym)
                if df_sym is not None:
                    p_last = _pos_at(df_sym, last_date)
                    if p_last is not None:
                        price = float(df_sym.iloc[p_last]["Close"])
                    else:
                        price = float(df_sym["Close"].iloc[-1])
                else:
                    price = float(pos["entry"])
                exit_price = price * (1 - self.slippage)
                shares = pos["shares"]
                proceeds = exit_price * shares
                entry_cost = pos["entry"] * shares
                self.capital += proceeds - self.fee * proceeds - self.fee * entry_cost
                self.trades.append(
                    {
                        "symbol": sym,
                        "entry_date": pos["entry_date"],
                        "entry_price": pos["entry"],
                        "exit_date": last_date,
                        "exit_price": exit_price,
                        "shares": shares,
                        "reason": "forced",
                    }
                )
                del self.portfolio[sym]
            self.equity_curve.append({"date": last_date, "value": float(self.capital)})

        # -------- save outputs --------
        pd.DataFrame(self.trades).to_csv("backtest_trades.csv", index=False)
        equity_df = pd.DataFrame(self.equity_curve)
        equity_df.to_csv("equity_curve.csv", index=False)

        if not equity_df.empty:
            cagr_val = cagr(equity_df["date"], equity_df["value"])
            mdd = max_drawdown(equity_df["value"])
            print(f"CAGR: {cagr_val:.2%}, Max Drawdown: {mdd:.2%}")


def _build_arg_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(description="Backtest engine for Breakout Momentum v3.0")
    p.add_argument("--config", type=str, default="backtest/config.yaml", help="Path to config YAML")
    p.add_argument("--start", type=str, help="Start date YYYY-MM-DD")
    p.add_argument("--end", type=str, help="End date YYYY-MM-DD")
    p.add_argument("--universe", type=str, help="Path to CSV with symbols")
    p.add_argument("--max-pos", type=int, help="Override MAX_POSITIONS")
    return p


def main(argv=None) -> None:
    args = _build_arg_parser().parse_args(argv)
    start = _parse_date(args.start)
    end = _parse_date(args.end)

    engine = BacktestEngine(
        config_path=args.config,
        start_date=start,
        end_date=end,
        universe_csv=args.universe,
        max_positions_override=args.max_pos,
    )
    engine.run()


if __name__ == "__main__":
    main()



